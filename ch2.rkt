#lang racket
(require "ch1.rkt")
(define (average a b)
  (/ (+ a b) 2))
(define (square x)
  (* x x))
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (neg-rat x)
  (make-rat (* (numer x))
            (denom x)))
(define (sub-rat x y)
  (add-rat x (neg-rat y)))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (reciprocal x)
  (make-rat (denom x) (numer x)))
(define (div-rat x y)
  (mul-rat x (reciprocal y)))
(define (equal-rat? x y)
  (= (* (numer x) (denom y)) (* (numer y) (denom x))))
(define (make-rat num denom)
  (let ((g (gcd num denom)))
    (cond ((> (* num denom) 0)
           (cons (abs (/ num g)) (abs (/ denom g))))
          (else
           (cons (* -1 (abs (/ num g))) (abs (/ denom g)))))))

(define (numer x)
  (car x))
(define (denom x)
  (cdr x))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

;; Exercise 2.2
(define (make-segment p1 p2)
  (cons p1 p2))
(define (start-segment s)
  (car s))
(define (end-segment s)
  (cdr s))
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (midpoint-segment s)
  (make-point (average (x-point (start-segment s)) (x-point (end-segment s)))
              (average (y-point (start-segment s) (y-point (end-segment s))))))
(define (length-segment s)
  (sqrt (+ (square (- (x-point (start-segment s))
                      (x-point (end-segment s))))
           (square (- (y-point (start-segment s))
                      (y-point (end-segment s)))))))
(define (rect-perimeter r)
  (+ (* 2 (length-segment (rect-L r))) (* 2 (length-segment (rect-W r)))))
(define (rect-area r)
  (* (length-segment (rect-L r)) (length-segment (rect-W r))))
(define (make-rect p1 p2 p3)
  (cons p1 (cons p2 p3)))
(define (rect-L r)
  (make-segment (car r) (car (cdr r))))
(define (rect-W r)
  (make-segment (car r) (cdr (cdr r))))


;; (define (cons x y)
;;   (define (dispatch m)
;;   (cond ((= m 0) x)
;;         ((= m 1) y)
;;         (else (error "Argument not 0 or 1 -- CONS" m))))
;;   dispatch)
;; (define (car pair)
;;   (pair 0))
;; (define (cdr pair)
;;   (pair 1))

;; Exercise 2.4
;; (define (cons x y)
;;   (lambda (m) (m x y)))
;; (define (car z)
;;   (z (lambda (p q) p)))
;; (define (cdr z)
;;   (z (lambda (p q) q)))

;; Exercise 2.5
;; (define (cons a b)
;;   (* (expt 2 a) (expt 3 b)))
;; (define (car z)
;;   (define (iter z acc)
;;     (cond ((odd? z) acc)
;;           (else (iter (/ z 2) (inc acc)))))
;;   (iter z 0))
;; (define (cdr z)
;;   (define (iter z acc)
;;     (cond ((> (remainder z 3) 0) acc)
;;           (else (iter (/ z 3) (inc acc)))))
;;   (iter z 0))

;; Exercise 2.6
;; Church numerals
;; (define zero (lambda (f) (lambda (x) x)))
;; (define one (lambda (f) (lambda (x) (f x))))
;; (define two (lambda (f) (lambda (x) (f (f x)))))
;; (define (add-1 n)
;;   (lambda (f) (lambda (x) (f ((n f) x)))))
;; (define (+ a b)
;;   (lambda (f) (lambda (x) ((a f) ((b f) x)))))
;; (define (* a b)
;;   (lambda (f) (lambda (x) ((a (b f)) x))))
;; (define three (+ one two))
;; (define (int-to-church n)
;;   (define (iter n f)
;;     (cond ((= n 0) f)
;;           (else (iter (dec n) (add-1 f)))))
;;   (iter n zero))
;; (define (church-to-int n)
;;   ((n inc) 0))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
(define (div-interval x y)
  (mul-interval x
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y)))))
(define (make-interval a b)
  (cons a b))

;; Exercise 2.7
(define (lower-bound i)
  (car i))
(define (upper-bound i)
  (cdr i))

;; Exercise 2.8
(define (sub-interval x y)
  (add-interval x
                (make-interval (* -1 (upper-bound y))
                               (* -1 (lower-bound y)))))

(define nil '())
(define (list-ref list ref)
  (define (iter list n)
    (cond ((= n 0) (car list))
          (else (iter (cdr list) (dec n)))))
  (iter list ref))

(define (length list)
  (define (iter list count)
    (cond ((null? list) count)
          (else (iter (cdr list) (inc count)))))
  (iter list 0))
(define (append list1 list2)
  (define (iter remaining-items acc)
    (cond ((null? remaining-items) acc)
          (else (iter (cdr remaining-items) (cons (car remaining-items) acc)))))
  (iter (reverse list1) list2))

;; Exercise 2.17
(define (last-pair list)
  (cond ((null? list) nil)
        ((null? (cdr list)) (car list))
        (else (last-pair (cdr list)))))

;; Exercise 2.18
(define (reverse list)
  (define (iter remaining-items acc)
    (cond ((null? remaining-items) acc)
          (else (iter (cdr remaining-items)
                      (cons (car remaining-items) acc)))))
  (iter list nil))

;; Exercise 2.19 -- TODO

;; Exercise 2.20
(define (same-parity . items)
  (define (iter remaining-items acc parity)
    (cond ((null? remaining-items) acc)
          ((= (remainder (car remaining-items) 2) parity)
           (iter (cdr remaining-items)
                 (cons (car remaining-items) acc)
                 parity))
          (else (iter (cdr remaining-items) acc parity))))
  (cond ((null? items) nil)
        (else (reverse (iter items nil (remainder (car items) 2))))))

(define (map f items)
  (define (iter remaining-items acc)
    (cond ((null? remaining-items) acc)
          (else (iter (cdr remaining-items)
                      (cons (f (car remaining-items))
                            acc)))))
  (reverse (iter items nil)))
