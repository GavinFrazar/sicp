#lang racket
(require "ch1.rkt")
(define (average a b)
  (/ (+ a b) 2))
(define (square x)
  (* x x))
(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (neg-rat x)
  (make-rat (* (numer x))
            (denom x)))
(define (sub-rat x y)
  (add-rat x (neg-rat y)))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (reciprocal x)
  (make-rat (denom x) (numer x)))
(define (div-rat x y)
  (mul-rat x (reciprocal y)))
(define (equal-rat? x y)
  (= (* (numer x) (denom y)) (* (numer y) (denom x))))
(define (make-rat num denom)
  (let ((g (gcd num denom)))
    (cond ((> (* num denom) 0)
           (cons (abs (/ num g)) (abs (/ denom g))))
          (else
           (cons (* -1 (abs (/ num g))) (abs (/ denom g)))))))

(define (numer x)
  (car x))
(define (denom x)
  (cdr x))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

;; Exercise 2.2
(define (make-segment p1 p2)
  (cons p1 p2))
(define (start-segment s)
  (car s))
(define (end-segment s)
  (cdr s))
(define (make-point x y)
  (cons x y))
(define (x-point p)
  (car p))
(define (y-point p)
  (cdr p))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (midpoint-segment s)
  (make-point (average (x-point (start-segment s)) (x-point (end-segment s)))
              (average (y-point (start-segment s) (y-point (end-segment s))))))
(define (length-segment s)
  (sqrt (+ (square (- (x-point (start-segment s))
                      (x-point (end-segment s))))
           (square (- (y-point (start-segment s))
                      (y-point (end-segment s)))))))
(define (rect-perimeter r)
  (+ (* 2 (length-segment (rect-L r))) (* 2 (length-segment (rect-W r)))))
(define (rect-area r)
  (* (length-segment (rect-L r)) (length-segment (rect-W r))))
(define (make-rect p1 p2 p3)
  (cons p1 (cons p2 p3)))
(define (rect-L r)
  (make-segment (car r) (car (cdr r))))
(define (rect-W r)
  (make-segment (car r) (cdr (cdr r))))


;; (define (cons x y)
;;   (define (dispatch m)
;;   (cond ((= m 0) x)
;;         ((= m 1) y)
;;         (else (error "Argument not 0 or 1 -- CONS" m))))
;;   dispatch)
;; (define (car pair)
;;   (pair 0))
;; (define (cdr pair)
;;   (pair 1))

;; Exercise 2.4
;; (define (cons x y)
;;   (lambda (m) (m x y)))
;; (define (car z)
;;   (z (lambda (p q) p)))
;; (define (cdr z)
;;   (z (lambda (p q) q)))

;; Exercise 2.5
;; (define (cons a b)
;;   (* (expt 2 a) (expt 3 b)))
;; (define (car z)
;;   (define (iter z acc)
;;     (cond ((odd? z) acc)
;;           (else (iter (/ z 2) (inc acc)))))
;;   (iter z 0))
;; (define (cdr z)
;;   (define (iter z acc)
;;     (cond ((> (remainder z 3) 0) acc)
;;           (else (iter (/ z 3) (inc acc)))))
;;   (iter z 0))

;; Exercise 2.6
;; Church numerals
;; (define zero (lambda (f) (lambda (x) x)))
;; (define one (lambda (f) (lambda (x) (f x))))
;; (define two (lambda (f) (lambda (x) (f (f x)))))
;; (define (add-1 n)
;;   (lambda (f) (lambda (x) (f ((n f) x)))))
;; (define (+ a b)
;;   (lambda (f) (lambda (x) ((a f) ((b f) x)))))
;; (define (* a b)
;;   (lambda (f) (lambda (x) ((a (b f)) x))))
;; (define three (+ one two))
;; (define (int-to-church n)
;;   (define (iter n f)
;;     (cond ((= n 0) f)
;;           (else (iter (dec n) (add-1 f)))))
;;   (iter n zero))
;; (define (church-to-int n)
;;   ((n inc) 0))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
(define (div-interval x y)
  (mul-interval x
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y)))))
(define (make-interval a b)
  (cons a b))

;; Exercise 2.7
(define (lower-bound i)
  (car i))
(define (upper-bound i)
  (cdr i))

;; Exercise 2.8
(define (sub-interval x y)
  (add-interval x
                (make-interval (* -1 (upper-bound y))
                               (* -1 (lower-bound y)))))

(define nil '())
(define (list-ref list ref)
  (define (iter list n)
    (cond ((= n 0) (car list))
          (else (iter (cdr list) (dec n)))))
  (iter list ref))

;; (define (length list)
;;   (define (iter list count)
;;     (cond ((null? list) count)
;;           (else (iter (cdr list) (inc count)))))
;;   (iter list 0))
;; (define (append list1 list2)
;;   (define (iter remaining-items acc)
;;     (cond ((null? remaining-items) acc)
;;           (else (iter (cdr remaining-items) (cons (car remaining-items) acc)))))
;;   (iter (reverse list1) list2))

;; Exercise 2.17
(define (last-pair list)
  (cond ((null? list) nil)
        ((null? (cdr list)) (car list))
        (else (last-pair (cdr list)))))

;; Exercise 2.18
(define (reverse list)
  (define (iter remaining-items acc)
    (cond ((null? remaining-items) acc)
          ((pair? remaining-items)
           (iter (cdr remaining-items)
                 (cons (car remaining-items) acc)))
          (else remaining-items)))
  (iter list nil))

;; Exercise 2.19 -- TODO

;; Exercise 2.20
(define (same-parity . items)
  (define (iter remaining-items acc parity)
    (cond ((null? remaining-items) acc)
          ((= (remainder (car remaining-items) 2) parity)
           (iter (cdr remaining-items)
                 (cons (car remaining-items) acc)
                 parity))
          (else (iter (cdr remaining-items) acc parity))))
  (cond ((null? items) nil)
        (else (reverse (iter items nil (remainder (car items) 2))))))

;; (define (map f items)
;;   (define (iter remaining-items acc)
;;     (cond ((null? remaining-items) acc)
;;           (else (iter (cdr remaining-items)
;;                       (cons (f (car remaining-items))
;;                             acc)))))
;;   (reverse (iter items nil)))

;; Exercise 2.23
(define (for-each action items)
  (define (iter remaining-items)
    (cond ((null? remaining-items) #t)
          (else (action (car remaining-items))
                (iter (cdr remaining-items)))))
  (iter items))

;; (define (count-leaves tree)
;;   (cond ((null? tree) 0)
;;         ((pair? tree) (+ (count-leaves (car tree))
;;                          (count-leaves (cdr tree))))
;;         (else 1)))
;; (define (count-leaves tree)
;;   (define (iter tree to-count acc)
;;     (cond ((null? tree) (if (null? to-count) acc
;;                             (iter (car to-count) (cdr to-count) acc)))
;;           ((pair? tree) (iter (car tree) (cons (cdr tree) to-count) acc))
;;           (else (if (null? to-count)
;;                     (inc acc)
;;                     (iter (car to-count) (cdr to-count) (inc acc))))))
;;   (iter tree nil 0))

;; Exercise 2.27
(define (deep-reverse items)
  (cond ((null? items) items)
        ((pair? items)
         (reverse (cons (deep-reverse (car items))
                        (deep-reverse (cdr items)))))
        (else items)))
(define x (list (list 1 2) (list 3 4)))

;; Exercise 2.28
(define (fringe tree)
  (cond ((null? tree) tree)
        ((pair? tree) (append (fringe (car tree))
                              (fringe (cdr tree))))
        (else (list tree))))

;; Exercise 2.29
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cdr mobile))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cdr branch))

(define (weigh structure)
  (cond
   ((null? structure) 0)
   ((pair? structure)
    (+ (weigh (branch-structure (left-branch structure)))
       (weigh (branch-structure (right-branch structure)))))
   (else structure)))

(define (balanced? mobile)
  (cond
   ((pair? mobile)
    (and (= (* (branch-length (left-branch mobile))
               (weigh (branch-structure (left-branch mobile))))
            (* (branch-length (right-branch mobile))
               (weigh (branch-structure (right-branch mobile)))))
         (balanced? (branch-structure (left-branch mobile)))
         (balanced? (branch-structure (right-branch mobile)))))
   (else #t)))

;; tests
;; (define m (make-mobile (make-branch 1 10) (make-branch 1 5)))
;; (define n (make-mobile (make-branch 3 m) (make-branch 3 m)))
;; (define p (make-mobile (make-branch 10 7) (make-branch 5 14)))
;; (define q (make-mobile (make-branch 3 p) (make-branch 3 p)))
;; (define r (make-mobile (make-branch 3 p) (make-branch 2 p)))

;; (balanced? m)
;; (balanced? n)
;; (balanced? p)
;; (balanced? q)
;; (balanced? r)

;; Exercise 2.30
;; Direct solution
;; (define (square-tree tree)
;;   (cond ((null? tree) tree)
;;         ((pair? tree) (cons (square-tree (car tree))
;;                             (square-tree (cdr tree))))
;;         (else (square tree))))
;; Solution using map
;; (define (square-tree tree)
;;   (map
;;    (lambda (sub-tree)
;;      (cond ((pair? sub-tree) (square-tree sub-tree))
;;            (else (square sub-tree))))
;;    tree))

;; Exercise 2.31
;; (define (map-tree f tree)
;;   (cond ((null? tree) tree)
;;         ((pair? tree)
;;          (cons (map-tree f (car tree))
;;                (map-tree f (cdr tree))))
;;         (else (f tree))))
(define (map-tree f tree)
  (map
   (lambda (sub-tree) (cond ((pair? sub-tree)
                             (map-tree f sub-tree))
                            (else (f sub-tree))))
   tree))
(define (square-tree tree) (map-tree square tree))

;; Exercise 2.32
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (head) (cons (car s) head)) rest)))))

;; bugged?
;; (define (accumulate op identity-elem sequence)
;;   (define (iter remaining acc)
;;     (cond ((null? remaining) acc)
;;           ((pair? remaining) (iter (cdr remaining)
;;                                    (op (car remaining) acc)))
;;           (else (op remaining acc))))
;;   (reverse (iter sequence identity-elem)))
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

;; Exercise 2.33
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) nil sequence))
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (inc y)) 0 sequence))

;; Exercise 2.34
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff acc-sum)
                (+ this-coeff (* acc-sum x)))
              0
              coefficient-sequence))

;; Exercise 2.35
(define (count-leaves t)
  (accumulate + 0 (map (lambda (x) 1) (fringe t))))

;; Exercise 2.36
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))
